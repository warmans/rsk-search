package server

import (
	"context"
	"fmt"
	"github.com/gorilla/handlers"
	"github.com/gorilla/mux"
	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
	grpc_zap "github.com/grpc-ecosystem/go-grpc-middleware/logging/zap"
	grpc_ctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
	grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery"
	grpc_validator "github.com/grpc-ecosystem/go-grpc-middleware/validator"
	grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/pkg/errors"
	"github.com/spf13/pflag"
	"github.com/warmans/rsk-search/pkg/flag"
	"github.com/warmans/rsk-search/pkg/server/middleware"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"log"
	"net"
	"net/http"
)

// GRPCService describes a gRPC GRPCService.
type GRPCService interface {
	RegisterGRPC(*grpc.Server)
	RegisterHTTP(ctx context.Context, router *mux.Router, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption)
}

type HTTPService interface {
	RegisterHTTP(ctx context.Context, router *mux.Router)
}

type GrpcServerConfig struct {
	GRPCAddr   string
	HTTPAddr   string
	ServerCert string
	ServerKey  string
}

func (c *GrpcServerConfig) RegisterFlags(fs *pflag.FlagSet, prefix string) {
	flag.StringVarEnv(fs, &c.GRPCAddr, prefix, "grpc-addr", "0.0.0.0:9090", "GRPC bind address")
	flag.StringVarEnv(fs, &c.HTTPAddr, prefix, "http-addr", ":8888", "HTTP bind address")
	flag.StringVarEnv(fs, &c.ServerCert, prefix, "grpc-tls-cert", "./x509/server_cert.pem", "The server TLS certificate")
	flag.StringVarEnv(fs, &c.ServerKey, prefix, "grpc-tls-key", "./x509/server_key.pem", "The server TLS key")
}

func NewServer(logger *zap.Logger, cfg GrpcServerConfig, grpcServices []GRPCService, httpServices []HTTPService) (*Server, error) {

	// Create tls based credential.
	creds, err := credentials.NewServerTLSFromFile(cfg.ServerCert, cfg.ServerKey)
	if err != nil {
		log.Fatalf("failed to create credentials: %v", err)
	}

	//panicHandler := grpc_recovery.WithRecoveryHandlerContext(func(ctx context.Context, p interface{}) (err error) {
	//	// the stack trace generated by the logging middleware is crap. This one should be correct.
	//	ctxzap.Extract(ctx).Error(
	//		fmt.Sprintf("PANIC: %v", p),
	//	)
	//	return fmt.Errorf("%v", p)
	//})

	grpc_prometheus.EnableHandlingTimeHistogram()

	grpcServer := grpc.NewServer(
		grpc.Creds(creds),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
			middleware.UnaryErrorObfuscatorInterceptor(),
			grpc_zap.UnaryServerInterceptor(
				logger,
				grpc_zap.WithMessageProducer(middleware.LogMessageProducer()),
				grpc_zap.WithLevels(middleware.CodeToLevel()),
			),
			grpc_recovery.UnaryServerInterceptor(),
			grpc_ctxtags.UnaryServerInterceptor(),
			grpc_validator.UnaryServerInterceptor(),
			grpc_prometheus.UnaryServerInterceptor,
		)),
		grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
			middleware.StreamErrorObfuscatorInterceptor(),
			grpc_zap.StreamServerInterceptor(
				logger,
				grpc_zap.WithMessageProducer(middleware.LogMessageProducer()),
				grpc_zap.WithLevels(middleware.CodeToLevel()),
			),
			grpc_recovery.StreamServerInterceptor(),
			grpc_ctxtags.StreamServerInterceptor(),
			grpc_validator.StreamServerInterceptor(),
			grpc_prometheus.StreamServerInterceptor,
		)),
	)

	// required for grpc_prometheus interceptors
	grpc_prometheus.Register(grpcServer)

	s := &Server{
		cfg:          cfg,
		logger:       logger,
		grpc:         grpcServer,
		grpcServices: grpcServices,
		httpServices: httpServices,
	}
	return s, nil
}

type Server struct {
	cfg          GrpcServerConfig
	logger       *zap.Logger
	grpc         *grpc.Server
	grpcServices []GRPCService
	httpServices []HTTPService
}

func (s *Server) StartGRPC() error {
	for _, srv := range s.grpcServices {
		srv.RegisterGRPC(s.grpc)
		s.logger.Info(fmt.Sprintf("Registered GRPC service %T", srv))
	}
	lis, err := net.Listen("tcp", s.cfg.GRPCAddr)
	if err != nil {
		return errors.Wrap(err, "failed to listen to address")
	}

	s.logger.Info("Starting gRPC server", zap.String("addr", lis.Addr().String()))
	defer s.logger.Info("gRPC server stopped")

	return s.grpc.Serve(lis)
}

func (s *Server) StartHTTP() error {
	defer s.logger.Info("HTTP server stopped")

	creds, err := credentials.NewClientTLSFromFile(s.cfg.ServerCert, "")
	if err != nil {
		log.Fatalf("failed to create credentials: %v", err)
	}

	router := mux.NewRouter()
	gwmux := runtime.NewServeMux()
	ctx := context.Background()
	opts := []grpc.DialOption{grpc.WithTransportCredentials(creds)}

	for _, srv := range s.httpServices {
		srv.RegisterHTTP(ctx, router)
	}

	for _, srv := range s.grpcServices {
		srv.RegisterHTTP(ctx, router, gwmux, s.cfg.GRPCAddr, opts)
		s.logger.Info(fmt.Sprintf("Registered HTTP service %T", srv))
	}

	// this must be after the service registration for whatever reason.
	router.PathPrefix("/").Handler(gwmux)

	s.logger.Info("Starting HTTP server", zap.String("addr", s.cfg.HTTPAddr))
	return http.ListenAndServe(s.cfg.HTTPAddr, handlers.CompressHandler(router))
}

func (s *Server) Stop() {
	s.grpc.Stop()
}
